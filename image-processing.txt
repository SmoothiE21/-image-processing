#include "opencv2/opencv.hpp"
using namespace std;
using namespace cv;
void intro()
{
	Mat im = imread("2.jpg", 1);
	imshow("Ez itt egy alma", im);
	waitKey(0);
}
//labor1
void lab01()
{
	Mat im1 = imread("2.jpg", 1);
	Mat im2 = imread("3.jpg", 1);
	imshow("Film", im1);
	waitKey(0);
	Mat im3 = im2.clone();
	for (float q = 0; q < 1.01; q += 0.02f)
	{
		addWeighted(im1, 1.0f - q, im2, q, 0, im3);
		imshow("Film", im3);
		waitKey(100);
		if (q<0.67 && q>0.65) imwrite("keverek.bmp", im3);
	}
	waitKey(0);
}
//labor2
void showMyImage(Mat &imBig, Mat &im1, int& index) {
	im1.copyTo(imBig(Rect((index % 6) * (im1.cols), (index / 6) * (im1.rows),
		im1.cols, im1.rows)));
	imshow("Ablak", imBig);
	index = (index + 1) % 18;
	waitKey();
}
void lab02()
{
	int index = 0;
	Mat rgb[3], &r = rgb[0], &g = rgb[1], &b = rgb[2];
	Mat im1 = imread("eper.jpg", 1);
	Mat imBig = Mat(im1.rows * 3, im1.cols * 6, im1.type());
	Mat z(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result1(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result2(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result3(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result4(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result5(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result6(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result7(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result8(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result9(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result10(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result11(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result12(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result13(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result14(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result15(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	Mat result16(im1.rows, im1.cols, CV_8UC1, Scalar(0));
	split(im1, rgb);
	merge(vector<Mat>{r, g, b}, im1);//ok //alap
	merge(vector<Mat>{z, g, b}, result);//1
	merge(vector<Mat>{r, z, b}, result1);//1
	merge(vector<Mat>{r, g, z}, result2);//1
	merge(vector<Mat>{r, z, z}, result3);//2
	merge(vector<Mat>{z, g, z}, result4);//2
	merge(vector<Mat>{z, z, b}, result5);//2
	merge(vector<Mat>{r, g, b}, result6);//3
	merge(vector<Mat>{g, b, r}, result7);//3
	merge(vector<Mat>{b, g, r}, result8);//3
	merge(vector<Mat>{r, b, g}, result9);//3
	merge(vector<Mat>{g, r, b}, result10);//3
	merge(vector<Mat>{b, r, g}, result11);//3
	merge(vector<Mat>{~r, g, b}, result12);//4
	merge(vector<Mat>{r, ~g, b}, result13);//4
	merge(vector<Mat>{r, g, ~b}, result14);//4
	merge(vector<Mat>{~r, ~g, ~b}, result16);//6

	

	

	showMyImage(imBig, im1, index);
	showMyImage(imBig, result, index);
	showMyImage(imBig, result1, index);
	showMyImage(imBig, result2, index);
	showMyImage(imBig, result3, index);
	showMyImage(imBig, result4, index);
	showMyImage(imBig, result5, index);
	showMyImage(imBig, result6, index);
	showMyImage(imBig, result7, index);
	showMyImage(imBig, result8, index);
	showMyImage(imBig, result9, index);
	showMyImage(imBig, result10, index);
	showMyImage(imBig, result11, index);
	showMyImage(imBig, result12, index);
	showMyImage(imBig, result13, index);
	showMyImage(imBig, result14, index);
	showMyImage(imBig, result16, index);
}
//labor3
void lab03_01()
{
	Mat imBe = imread("2.jpg", 1);
	Mat imKi = imBe.clone();
	float szamok[9] = { 0, 0, 0, 0, 0, 1, 0, 0, 0 };
	Mat maszk = Mat(3, 3, CV_32FC1, szamok);
	for (int i = 0; i < 50; i++)
	{
		filter2D(imBe, imBe, -1, maszk);
		imshow("Kep", imBe);
		waitKey(50);
	}
}
void lab03_02()
{
	Mat imBe = imread("2.jpg", 1);
	Mat imKi = imBe.clone();
	float szamok[9] = {0.1, 0.1, 0.1, 0.1, 0.2, 0.1, 0.1, 0.1, 0.1};
	Mat maszk = Mat(3, 3, CV_32FC1, szamok);
	for (int i = 0; i < 100; i++)
	{
		filter2D(imBe, imBe, -1, maszk);
		imshow("Kep", imBe);
		waitKey(50);
	}
}
void lab03_03()
{
	Mat imBe = imread("faliszonyeg.jpg", 1);
	Mat imKi = imBe.clone();
	for (int k = 1; k < 5; k++)
	{
		float szamok[9] = { 0, -k / 4, 0, -k / 4, 1 + k, -k / 4, 0, -k / 4, 0 };
		Mat maszk = Mat(3, 3, CV_32FC1, szamok);
		filter2D(imBe, imKi, -1, maszk);
		imshow("Kep", imKi);
		waitKey(1000);
	}
}
void lab03_04()
{
	Mat imBe = imread("2.jpg", 1);
	Mat imKi = imBe.clone();
	for (int k = 1; k <= 1001; k+=2)
	{
		blur(imBe, imKi, Size(k, k));
		//GaussianBlur(imBe, imKi, Size(k, k), 1);
		imshow("Kep", imKi);
		waitKey(1000);
	}
}
void lab03_05()
{
	Mat imBe = imread("2.jpg", 1);
	Mat imKi = imBe.clone();
	for (int db = 0; db < 20; ++db) {
		line(imBe, Point(rand() % imBe.cols, rand() % imBe.rows),
			Point(rand() % imBe.cols, rand() % imBe.rows),
			Scalar(0, 0, 0, 0), 1 + db % 2);
	}
	for (int k = 1; k <= 1001; k += 2)
	{
		medianBlur(imBe, imKi, k);
		imshow("Kep", imKi);
		waitKey(1000);
	}
}
void lab03_06() {
	Mat imBe = imread("amoba.png", 1);
	for (int k = 1; k < 2000; k = k + 2) {
		medianBlur(imBe, imBe, k);
		imshow("Kep", imBe);
		waitKey(50);
	}
}
void lab04()
{
	Mat imBe = imread("2.jpg", 1);
	Mat imKi1 = imBe.clone();
	Mat imKi2 = imBe.clone();
	Mat imKi3 = imBe.clone();
	Mat imKi4 = imBe.clone();
	Mat imKi5 = imBe.clone();
	Mat imKi6 = imBe.clone();
	Mat imKi = imBe.clone();
	cvtColor(imBe, imBe, COLOR_BGR2GRAY);
	float szamok1[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };
	float szamok2[9] = { 1, 0, -1, 1, 0, -1, 1, 0, -1 };
	float szamok3[9] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };
	float szamok4[9] = { 1, 1, 1, 0, 0, 0, -1, -1, -1 };
	Mat maszk1 = Mat(3, 3, CV_32FC1, szamok1);
	Mat maszk2 = Mat(3, 3, CV_32FC1, szamok2);
	Mat maszk3 = Mat(3, 3, CV_32FC1, szamok3);
	Mat maszk4 = Mat(3, 3, CV_32FC1, szamok4);
	filter2D(imBe, imKi1, -1, maszk1);
	filter2D(imBe, imKi2, -1, maszk2);
	filter2D(imBe, imKi3, -1, maszk3);
	filter2D(imBe, imKi4, -1, maszk4);
	double alpha = 0.5;
	addWeighted(imKi1, alpha, imKi2, alpha, 0, imKi5);
	addWeighted(imKi3, alpha, imKi4, alpha, 0, imKi6);
	addWeighted(imKi5, alpha, imKi6, alpha, 0, imKi);
	imshow("Film", imKi);
	waitKey(0);
}
void lab04_Canny()
{
	Mat src1;
	src1 = imread("3.jpg", CV_LOAD_IMAGE_COLOR);
	namedWindow("Original image", CV_WINDOW_AUTOSIZE);
	imshow("Original image", src1);
	Mat gray, edge, draw;
	cvtColor(src1, gray, CV_BGR2GRAY);
	Canny(gray, edge, 50, 150, 3);
	edge.convertTo(draw, CV_8U);
	namedWindow("image", CV_WINDOW_AUTOSIZE);
	imshow("image", draw);
	waitKey(0);
}
//labor 5 - Hisztogramm
void setChannel(Mat im, int x, int y, int c, uchar v) {
	im.data[y * im.step[0] + x * im.step[1] + c] = v;
}
uchar getChannel(Mat im, int x, int y, int c) {
	return im.data[y * im.step[0] + x * im.step[1] + c];
}
const int Ng = 256;
void drawHist(Mat im) {
	// erre a képre rajzoljuk a hisztogramot
	Mat imHist(Size(3 * Ng, Ng * im.channels()), im.type());
	for (int ch = 0; ch < im.channels(); ++ch) {
		Mat roi = imHist(Rect(0, Ng * ch, 3 * Ng, Ng));
		roi.setTo(Scalar((ch == 0)*(Ng - 1), (ch == 1)*(Ng - 1), (ch == 2)*(Ng - 1), 0));
		// kiszámoljuk a hisztogramot a ch csatornán
		int hist[Ng] = { 0 };
		for (int y = 0; y < im.rows; ++y) {
			for (int x = 0; x < im.cols; ++x)
				hist[getChannel(im, x, y, ch)]++;
		}
		// megkeressük a leggyakoribb intenzitás számosságát
		int maxCol = 0;
		for (int i = 0; i < Ng; ++i) {
			if (hist[i] > maxCol) {
				maxCol = hist[i];
			}
		}
		// megrajzoljuk a hisztogramot a ch csatornán, fentről lógó oszlopokkal
		for (int i = 0; i < Ng; ++i) {
			// hármasszabály
			int colHeight = round(250 * hist[i] / maxCol);
			if (colHeight > 0) {
				roi = imHist(Rect(3 * i, Ng * ch, 3, colHeight));
				roi.setTo(Scalar(i, i, i, 0));
			}
		}
		// tükrözzük a kirajzolt hisztogramot, hogy álló oszlopaink legyenek
		roi = imHist(Rect(0, Ng * ch, 3 * Ng, Ng));
		flip(roi, roi, 0);
	}
	imshow("Histogram", imHist);
	waitKey();
}
void equalizeHistogram(Mat im) {
	if (!(im.channels() % 2)) {
		return;
	}
	// ha színes a kép, átalakítjuk YCrCb kódolásra
	if (im.channels() == 3) {
		cvtColor(im, im, COLOR_BGR2YCrCb);
	}
	// most mindenképpen a 0-ás színcsatornát kell nekünk kiegyenlíteni
	// kiszámoljuk a hisztogramot a 0-ás csatornán
	int H[Ng] = { 0 };
	for (int x = 0; x < im.cols; ++x) {
		for (int y = 0; y < im.rows; ++y) {
			H[*im.ptr(y, x)]++;
		}
	}
	// kiszámoljuk az új színeket
	int uj[Ng];
	int sum = 0;
	for (int n = 0; n < Ng; ++n) {
		uj[n] = (sum + H[n] / 2) / (im.cols * im.rows / Ng);
		if (uj[n] > Ng - 1) uj[n] = Ng - 1;
		sum += H[n];
	}
	// átfestjük a képet az új színekkel, a 0-ás csatornán
	for (int x = 0; x < im.cols; ++x) {
		for (int y = 0; y < im.rows; ++y) {
			im.ptr(y, x)[0] = uj[*im.ptr(y, x)];
		}
	}
	// ha színes a kép, visszaalakítjuk BGR kódolásra
	if (im.channels() == 3) {
		cvtColor(im, im, COLOR_YCrCb2BGR);
	}
}
void lab05()
{
	Mat im = imread("japan.jpg", 1);
	imshow("japan", im);
	waitKey();
	drawHist(im);
	equalizeHistogram(im); 
	imshow("japan", im);
	drawHist(im);
	waitKey();

}
//labor 5 link
/*#include "opencv2/highgui.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include <iostream>
using namespace std;
using namespace cv;
int main(int argc, char** argv)
{
	CommandLineParser parser(argc, argv, "{@input | muzeum.jpg | input image}");
	Mat src = imread("muzeum.jpg", IMREAD_COLOR);
	if (src.empty())
	{
		return EXIT_FAILURE;
	}
	vector<Mat> bgr_planes;
	split(src, bgr_planes);
	int histSize = 256;
	float range[] = { 0, 256 }; //the upper boundary is exclusive
	const float* histRange = { range };
	bool uniform = true, accumulate = false;
	Mat b_hist, g_hist, r_hist;
	calcHist(&bgr_planes[0], 1, 0, Mat(), b_hist, 1, &histSize, &histRange, uniform, accumulate);
	calcHist(&bgr_planes[1], 1, 0, Mat(), g_hist, 1, &histSize, &histRange, uniform, accumulate);
	calcHist(&bgr_planes[2], 1, 0, Mat(), r_hist, 1, &histSize, &histRange, uniform, accumulate);
	int hist_w = 512, hist_h = 400;
	int bin_w = cvRound((double)hist_w / histSize);
	Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));
	normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());
	for (int i = 1; i < histSize; i++)
	{
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(b_hist.at<float>(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(b_hist.at<float>(i))),
			Scalar(255, 0, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(g_hist.at<float>(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(g_hist.at<float>(i))),
			Scalar(0, 255, 0), 2, 8, 0);
		line(histImage, Point(bin_w*(i - 1), hist_h - cvRound(r_hist.at<float>(i - 1))),
			Point(bin_w*(i), hist_h - cvRound(r_hist.at<float>(i))),
			Scalar(0, 0, 255), 2, 8, 0);
	}
	imshow("Source image", src);
	imshow("calcHist Demo", histImage);
	waitKey();
	return EXIT_SUCCESS;
}
//labor 5 link 2
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include <iostream>
using namespace cv;
using namespace std;
int main(int argc, char** argv)
{
	CommandLineParser parser(argc, argv, "{@input | lena.jpg | input image}");
	Mat src = imread("muzeum.jpg", IMREAD_COLOR);
	if (src.empty())
	{
		cout << "Could not open or find the image!\n" << endl;
		cout << "Usage: " << argv[0] << " <Input image>" << endl;
		return -1;
	}
	cvtColor(src, src, COLOR_BGR2GRAY);
	Mat dst;
	equalizeHist(src, dst);
	imshow("Source image", src);
	imshow("Equalized Image", dst);
	waitKey();
	return 0;
}
*/
//labor 6 - Morfologia
void lab06_A()
{
	Mat imBe = imread("pityoka.png", 1);
	imshow("kep", imBe);
	waitKey();
	Mat im = imBe.clone();
	Mat imKi = imBe.clone();
	//szukites
	for(int i = 1; i <= 10; i++)
	{
		erode(im, im, getStructuringElement(MORPH_RECT, Size(3, 3)));
		imshow("kep1", im);
		waitKey();
	} 
	//tagitas
	for (int i = 1; i <= 10  ; i++)
	{
		dilate(im, im, getStructuringElement(MORPH_RECT, Size(3, 3)));
		imshow("kep1", im);
		waitKey();
	}
	//tagitas
	for (int i = 1; i <= 10; i++)
	{
		dilate(imKi, imKi, getStructuringElement(MORPH_RECT, Size(3, 3)));
		imshow("kep2", imKi);
		waitKey();
	}
	//szukites
	for (int i = 1; i <= 10; i++)
	{
		erode(imKi, imKi, getStructuringElement(MORPH_RECT, Size(3, 3)));
		imshow("kep2", imKi    );
		waitKey();
	}
}
void lab06_B()
{
	Mat imBe = imread("pityoka.png", 1);
	imshow("kep", imBe);
	waitKey();
	Mat im = imBe.clone();
	Mat imKi = imBe.clone();
	//szukites
	for (int i = 1; i <= 10; i++)
	{
		erode(im, im, getStructuringElement(MORPH_ELLIPSE, Size(3, 3)));
		imshow("kep1", im);
		waitKey();
	}
	//tagitas
	for (int i = 1; i <= 10; i++)
	{
		dilate(im, im, getStructuringElement(MORPH_ELLIPSE, Size(3, 3)));
		imshow("kep1", im);
		waitKey();
	}
	//tagitas
	for (int i = 1; i <= 10; i++)
	{
		dilate(imKi, imKi, getStructuringElement(MORPH_ELLIPSE, Size(3, 3)));
		imshow("kep2", imKi);
		waitKey();
	}
	//szukites
	for (int i = 1; i <= 10; i++)
	{
		erode(imKi, imKi, getStructuringElement(MORPH_ELLIPSE, Size(3, 3)));
		imshow("kep2", imKi);
		waitKey();
	}
}
void lab06_C()
{
	Mat imBe = imread("bond.jpg", 1);
	Mat im = imBe.clone();
	Mat im1 = imBe.clone();
	//fekete vonalak tagitas
	for (int db = 0; db < 20; ++db) {
		line(im, Point(rand() % im.cols, rand() % im.rows),
			Point(rand() % im.cols, rand() % im.rows),
			Scalar(0, 0, 0, 0), 1 + db % 2);
	}
	for (int i = 1; i <= 10; i++)
	{
		dilate(im, im, getStructuringElement(MORPH_ELLIPSE, Size(i, i)));
		imshow("kep2", im);
		waitKey();
	}
	//feher vonalak szukites
	for (int db = 0; db < 20; ++db) {
		line(im1, Point(rand() % im1.cols, rand() % im1.rows),
			Point(rand() % im1.cols, rand() % im1.rows),
			Scalar(255, 255, 255, 255), 1 + db % 2);
	} 
	for (int i = 1; i <= 10; i++)
	{
		erode(im1, im1, getStructuringElement(MORPH_ELLIPSE, Size(i, i)));
		imshow("kep3", im1);
		waitKey();
	}
}
void lab06_D()
{
	Mat imBe = imread("bond.jpg", 1);
	Mat im = imBe.clone();
	for (int i = 1; i <= 10; i++)
	{
		morphologyEx(imBe, im, MORPH_GRADIENT, getStructuringElement(MORPH_RECT, Size(i, i)));
		imshow("kep3", im);
		waitKey();
	}
}
void lab06_E() {
	Mat imBe = imread("kukac.png", 0);
	Mat imH = imBe.clone();
	Mat imKi = imBe.clone();
	Mat imKi1 = imBe.clone();
	imshow("kep", imBe);
	waitKey(0);
	for (int x = 0; x < imH.cols; ++x) {
		imH(Rect(x, 0, 1, imH.rows)).setTo(Scalar(x * 256 / imH.cols));
	}
	addWeighted(imH, 0.9, imBe, 0.1, 0, imKi);
	//imshow("kep", imKi);
	//waitKey(0);
	for (int i = 3; i <= 11; ++i)
	{
		Mat element = getStructuringElement(MORPH_RECT, Size(i, i));
		morphologyEx(imKi, imKi1, MORPH_TOPHAT, element);
		threshold(imKi1, imKi1, 10, 255, THRESH_BINARY);
		imshow("tophat", imKi1);
		waitKey(300);
	}
	waitKey(0);
	addWeighted(imH, 0.9, imBe, -0.1, 25, imKi);
	for (int i = 3; i <= 11; ++i)
	{
		Mat element = getStructuringElement(MORPH_RECT, Size(i, i));
		morphologyEx(imKi, imKi1, MORPH_BLACKHAT, element);
		threshold(imKi1, imKi1, 10, 255, THRESH_BINARY);
		imshow("blackhat", imKi1);
		waitKey(300);
	}
	imshow("kep", imKi);
	waitKey(0);
}
void lab07_1() {
	Mat imBe = imread("forest.png", 1);
	Mat imKi1 = imBe.clone();
	imshow("Kep", imBe);
	waitKey();
	//inicializalas
	Mat lut(1, 256, CV_8UC3);
	float brightness = 0.6;
	float contrast = 4;
	float gamma = 1;

	for (int i = 0; i < 255; ++i) {
		float value = i / 255.;//normalizalas
		value = pow(value, 1. / gamma);
		value = contrast * (value - .5) + .5;
		value = brightness + value; 
		if (value < 0) {
			value = 0;
		}
		if (value > 1) {
			value = 1;
		}
		value = value * 255;
		lut.at<cv::Vec3b>(0, i) = cv::Vec3b(value, value, value);

	}
	LUT(imBe, lut, imKi1);
	imshow("KEP", imKi1);
	waitKey();

}
void lab07_2()
{
	Mat imBe = imread("forest.png", 1);
	Mat imKi = imBe.clone();
	imshow("Kep", imBe);
	waitKey();
	//inicializalas
	float b = 0; //brightness
	float c = 2; //contrast
	float s = 2; //saturation
	float t = (1.0 - c) / 2.0;
	float sr = (1 - s) * 0.3086;// 0.3086 or 0.2125
	float sg = (1 - s) * 0.6094;// 0.6094 or 0.7154
	float sb = (1 - s) * 0.0820;// 0.0820 or 0.0721
	float customMatrix[4][4] = {
	{c * (sr + s), c * (sr), c * (sr), 0},
	{c * (sg), c * (sg + s), c * (sg), 0},
	{c * (sb), c * (sb), c * (sb + s), 0},
	{t + b, t + b, t + b, 1}
	};
	imBe.convertTo(imKi, CV_32FC4, 1 / 255.);
	cvtColor(imKi, imKi, COLOR_BGR2RGBA);
	imKi = imKi.reshape(1, imBe.cols * imBe.rows);
	imKi *= Mat(4, 4, CV_32FC1, customMatrix);
	imKi = imKi.reshape(4, imBe.rows);

	
	cvtColor(imKi, imKi, COLOR_RGBA2BGR);
	imKi.convertTo(imKi, CV_8UC3, 255);
	imshow("kep1", imKi);
	waitKey();
}
void lab08_1() 
{
	Mat imBe = imread("amoba.png", 0);
	Mat imKi = imBe.clone();
	Mat imX = imBe.clone();
	imshow("Kep", imBe);
	waitKey();
	//tavolsag transzformacio
	distanceTransform(imBe,imKi,DIST_L2,3,CV_32F);
	//Átkonvertáljuk a 32 bites kimenetet 8 bites színmélységű képre
	imKi.convertTo(imKi, CV_8U, 5, 0);
	// Készítünk egy kerek 5x5-ös strukturáló elemet 
	//getStructuringElement(MORPH_ELLIPSE, Size(5, 5));
	dilate(imKi, imX, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
	imX.copyTo(imKi, imKi);
	imshow("kep1", imKi);
	for (int i = 1; i <= 20; i++)
	{
		dilate(imKi, imX, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
		//imshow("Kep1", imX);
		//waitKey();
		imX.copyTo(imKi, imKi);
	}
	imshow("Kep2", imKi);
	waitKey();
}
//int Golay[72] = { 1,1,1,-1,1,-1,0,0,0,
//				-1,1,-1,1,1,0,-1,0,0,
//				1,-1,0,1,1,0,1,-1,0,
//				-1,0,0,1,1,0,-1,1,-1,
//				0,0,0,-1,1,-1,1,1,1,
//				0,0,-1,0,1,1,-1,1,-1,
//				0,-1,1,0,1,1,0,-1,1,
//				-1,1,-1,0,1,1,0,0,-1 };
//uchar getGray(Mat im, int x, int y)
//{
//	return im.data[y * im.step[0] + x];
//}
//
//void setBlack(Mat im, int x, int y)
//{
//	im.data[y * im.step[0] + x] = 0;
//}
//
//void lab08_2()
//{
//	Mat imBe = imread("kep2.png", 0);
//	Mat imKi = imBe.clone();
//	imshow("kep", imBe);
//	waitKey();
//
//	int count;
//	int i,j;
//	do {
//		count = 0;
//		for (int l = 0; l < 8; l++)
//		{
//			for(int x=1; x<imBe.cols-1; x++)
//				for(int y=1; y<imBe.rows-1; y++)
//					if (getGray(imBe, x, y) > 0)
//					{
//						bool erase = true;
//						int index = 9 * l;
//						for (j = y - 1; j <= y + 1; j++) for (i = x - 1; i <= x + 1; i++)
//						{
//							if (Golay[index] == 1 && getGray(imBe, i, j) == 0 || Golay[index] == 0 && getGray(imBe, i, j) > 0)
//							{
//								erase = false;
//							}
//							index++;
//						}
//						if (erase)
//						{
//							setBlack(imKi, x, y);
//							count++;
//						}
//					}
//			imBe = imKi.clone();
//		}
//		imshow("kep1", imKi);
//		waitKey();
//	} 
//	while (count > 0);
//	waitKey();
//}
//void lab09() 
//{
//	Mat imBe = imread("agy.bmp", 0);
//	Mat imKi = imBe.clone();
//	imshow("kep", imBe);
//	waitKey();
//
//	const int Ng = 256;
//	const int c = 3;
//
//	const float m = 1.5f;
//	const float mm = -1.0f / (m - 1.0f);
//	const float eps = 0.00000001;
//
//	float u[c][Ng]; //a fuzzy tagsagfuggvenyek matrixa (particios matrix)
//	float v[c]; //az osztaly prototipusok tombje
//	float d2[c][Ng]; // d2[i][l]=(l-v[i])²
//	int H[Ng] = { 0 }; //a kep hisztogramja
//
//	//kiszamol kep hisztogramjat
//	
//	for (int y = 0; y < imKi.rows; ++y) {
//			for (int x = 0; x < imKi.cols; ++x)
//				H[getGray(imKi, x, y)]++;
//	}
//
//	for (int i = 0; i < c; ++i) {
//		v[i] = 255.0f * (i + 1.0f) / (2.0f * c);
//	}
//
//	// A konvergenciához húsz ciklus elég lesz
//	for (int ciklus = 0; ciklus < 20; ++ciklus) {
//		// A partíciós matrix újraszámítása. Beiktattunk egy védelmet arra az esetre amikor d2[][]
//		// valamely értéke zéró, mert ilyenkor zéróval kellene osztanunk
//		for (int l = 0; l < Ng; ++l) {
//			for (int i = 0; i < c; ++i) {
//				d2[i][l] = (l - v[i]) * (l - v[i]);
//			}
//			int winner = 0;
//			for (int i = 0; i < c; ++i) {
//				if (d2[winner][l] > d2[i][l]) {
//					winner = i;
//				}
//			}
//			if (d2[winner][l] < eps) {
//				for (int i = 0; i < c; ++i) {
//					u[i][l] = 0.0f;
//				}
//				u[winner][l] = 1.0f;
//			}
//			else {
//				float sum = 0;
//				for (int i = 0; i < c; ++i) {
//					u[i][l] = pow(d2[i][l], mm);
//					sum += u[i][l];
//				}
//				for (int i = 0; i < c; ++i) {
//					u[i][l] /= sum;
//				}
//			}
//		}
//		// az osztályprototípusok újraszámolása
//		for (int i = 0; i < c; ++i) {
//			float sumUp = 0.0f;
//			float sumDn = 0.0f;
//			for (int l = 0; l < Ng; ++l) {
//				sumUp += H[l] * pow(u[i][l], m) * l;
//				sumDn += H[l] * pow(u[i][l], m);
//			}
//			v[i] = sumUp / sumDn;
//		}
//	}
//
//	Mat lut(1, 256, CV_8U);
//	for (int l = 0; l < Ng; ++l) {
//		int winner = 0;
//		for (int i = 1; i < c; ++i) {
//			if (u[i][l] > u[winner][l]) {
//				winner = i;
//			}
//		}
//		lut.at<uchar>(0, l) = round(v[winner]);
//	}
//	cv::LUT(imKi, lut, imKi);
//
//	imshow("kep1", imKi);
//	waitKey();
//	
//	Mat imF(Size(768, 400), CV_8UC3, Scalar(0, 0, 0, 0));
//	for (int i = 0; i < c; ++i) {
//		for (int l = 0; l < Ng; ++l) {
//			circle(imF, Point(1 + 3 * l, round(400.0 * (1.0f - u[i][l]))), 2,
//				Scalar(255 * (i == 0), 255 * (i == 1), 255 * (i == 2), 0));
//		}
//	}
//	imshow("Tagsagfuggvenyek", imF);
//	waitKey();
//}
//

//labor 10_A
#include <iostream>
uchar getGray1(Mat im, int x, int y) {
	return im.data[y * im.step[0] + x * im.step[1]];
}
void setBlack1(Mat im, int x, int y) {
	im.data[y * im.step[0] + x * im.step[1]] = 0;
}
void setBlack2(Mat im, int x, int y, int ertek) {
	im.data[y * im.step[0] + x * im.step[1]] = ertek;
}
void lab10_A()
{
	Mat imBe = imread("hod.jpg", 1);
	Mat imKi;
	imshow("kep", imBe);
	waitKey(0);
	const int R = 89;
	Mat rgb[3], & r = rgb[0], & g = rgb[1], & b = rgb[2];
	split(imBe, rgb);
	Mat result;
	merge(vector<Mat>{g, g, g}, result);
	imshow("kep1", result);
	waitKey(0);
	Mat gray = imBe.clone();
	Mat edge, draw;
	cvtColor(imBe, gray, COLOR_BGR2GRAY);
	Canny(imBe, edge, 400, 700);
	edge.convertTo(draw, CV_8U);
	imshow("kep2", draw);
	waitKey(0);
	Mat black = imBe.clone();
	black.setTo(Scalar(0));
	cvtColor(black, black, COLOR_BGR2GRAY);
	//Point center = (100, 100);
	const Scalar& color = (255);
	const Scalar& col = (255, 125, 255);
	int thickness = 1;
	int lineType = 8;
	int shift = 0;
	circle(black, Point(black.cols / 2, black.rows / 2), R, color, thickness, lineType, shift);
	imshow("kep3", black);
	waitKey(0);
	int sizeCirc = black.cols * black.rows;
	Point circPoint[10 * R];
	int nrcPix = 0;
	for (int i = 0; i < black.cols; i++)
	{
		for (int j = 0; j < black.rows; j++)
		{
			if (getGray1(black, i, j) > 0)
			{
				circPoint[nrcPix++] = Point(i - black.cols / 2, j - black.rows / 2);
			}
		}
	}
	Mat black1 = imBe.clone();
	black1.setTo(Scalar(0));
	cvtColor(black1, black1, COLOR_BGR2GRAY);
	for (int i = 0; i < draw.cols; i++)
	{
		for (int j = 0; j < draw.rows; j++)
		{
			int ertek = getGray1(draw, i, j);
			if (ertek > 0)
			{
				for (int k = 0; k < nrcPix; k++)
				{
					int elso = i + circPoint[k].x;
					int masodik = j + circPoint[k].y;
					int ertek1 = getGray1(black1, elso, masodik);
					//cout << elso << " " << masodik <<" - "<< ertek << endl;
					if (ertek1 < 255 && elso >= 0 && elso < black1.cols && masodik >= 0 && black1.rows)
					{
						setBlack2(black1, elso, masodik, (ertek1 + 1));
					}
				}
			}
		}
	}
	imshow("kep4", black1);
	waitKey(0);
	for (int i = 0; i < 5; i++) {
		Point pmax;
		minMaxLoc(black1, NULL, NULL, NULL, &pmax);
		circle(imBe, pmax, R, col, thickness, lineType, shift);
		imshow("kep5", imBe);
		waitKey(0);
		for (int j = 0; j < 5; j++)
		{
			circle(black1, pmax, j, Scalar(0), 2);
		}
	}
}
///labor10 B feladat
//#include "opencv2/imgcodecs.hpp"
//#include "opencv2/highgui.hpp"
//#include "opencv2/imgproc.hpp"
//using namespace cv;
//using namespace std;
//int main(int argc, char** argv)
//{
//	const char* filename = argc >= 2 ? argv[1] : "smarties.png";
//	// Loads an image
//	Mat src = imread("smarties.png", IMREAD_COLOR);
//	// Check if image is loaded fine
//	if (src.empty()) {
//		printf(" Error opening image\n");
//		printf(" Program Arguments: [image_name -- default %s] \n", filename);
//		return EXIT_FAILURE;
//	}
//	Mat gray;
//	cvtColor(src, gray, COLOR_BGR2GRAY);
//	medianBlur(gray, gray, 5);
//	vector<Vec3f> circles;
//	HoughCircles(gray, circles, HOUGH_GRADIENT, 1,
//		gray.rows / 16,  // change this value to detect circles with different distances to each other
//		100, 30, 1, 30 // change the last two parameters
//   // (min_radius & max_radius) to detect larger circles
//	);
//	for (size_t i = 0; i < circles.size(); i++)
//	{
//		Vec3i c = circles[i];
//		Point center = Point(c[0], c[1]);
//		// circle center
//		circle(src, center, 1, Scalar(0, 100, 100), 3, LINE_AA);
//		// circle outline
//		int radius = c[2];
//		circle(src, center, radius, Scalar(255, 0, 255), 3, LINE_AA);
//	}
//	imshow("detected circles", src);
//	waitKey();
//	return EXIT_SUCCESS;
//}

//labor 11
uchar getGray(const Mat& im, int x, int y)
{
	return im.data[y * im.step[0] + x * im.step[1]];
}

void setGray(Mat& im, int x, int y, uchar v)
{
	im.data[y * im.step[0] + x] = v;
}
void getColor(Mat im, int x, int y, uchar& blue, uchar& green, uchar& red)
{
	blue=im.data[y * im.step[0] + x * im.step[1] + 0];
	green = im.data[y * im.step[0] + x * im.step[1] + 1];
	red = im.data[y * im.step[0] + x * im.step[1] + 2];
}
void setColor(Mat im, int x, int y, uchar blue, uchar green, uchar red)
{
	im.data[y * im.step[0] + x * im.step[1] + 0 ]=blue; // blue
	im.data[y * im.step[0] + x * im.step[1] + 1]=green;//green
	im.data[y * im.step[0] + x * im.step[1] + 2]=red; //red
}
int compare(const void* p1, const void* p2)
{
	if (p1 > p2)
	{
		return 1;
	}
	else if (p1 < p2)
	{
		return -1;
	}
	else return 0;
}
void lab11() 
{
	const uchar bits[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };
	// a kifelé folyás irányainak x és y komponense
	const int dx[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };
	const int dy[8] = { 0, -1, -1, -1, 0, 1, 1, 1 };
	// betöltjük a szegmentálandó színes képet
	Mat imColor = imread("3.jpg", 1);
	// készítünk belőle egy szürke verziót
	Mat imO(imColor.cols, imColor.rows, CV_8UC1);
	cvtColor(imColor, imO, CV_BGR2GRAY);
	imshow("Szines", imColor);
	waitKey();
	imshow("Szurke", imO);
	waitKey();
	// Ez a kép tárolja majd a kiszámított gradiens értéket minden képpontban
	Mat imG = imO.clone();
	// Ez a kép tárolja majd minden képpont szomszédságában található legkisebb gradiens
	//értéket
		Mat imE = imO.clone();
	// Ez a kép tárolja a kifele folyás irányát minden képpontban
	Mat imKi = imO.clone();
	// Ez a kép tárolja a befele folyás irányait (bitenként) minden képpontban
	Mat imBe = imO.clone();
	//
	// A szegmentált kép lesz (vízgyűjtők átlagolt színével)
	Mat imSegm = imColor.clone();
	// A szegmentált kép lesz (vízgyűjtők medián színével)
	Mat imSegmMed = imColor.clone();
	// Bináris kép mely megmutatja, hogy melyik képpontokban állítottuk már be a kifele
	//folyást
		Mat imMap = imO.clone();
	// Gradiensek számításához használt 16 bites előjeles kódolású kép
	Mat imL(imColor.cols, imColor.rows, CV_16SC1);
	// felbontjuk a színes képet színcsatornáira
	vector<Mat> imColors;
	split(imColor, imColors);
	// A bemeneti kép három színcsatornáját fogjuk itt tárolni, ezekből számoljuk a
	//gradienseket
		Mat imRed = imColors[2];
	Mat imGreen = imColors[1];
	Mat imBlue = imColors[0];
	// Ezen a képen összegezzük a három színcsatorna gradienseit
	Mat imSum = imO.clone();
	imSum.setTo(Scalar(0));
	// kék színcsatorna gradienseit adjuk hozzá az imSum-hoz
	Sobel(imBlue, imL, imL.depth(), 1, 0);
	convertScaleAbs(imL, imE);
	Sobel(imBlue, imL, imL.depth(), 0, 1);
	convertScaleAbs(imL, imG);
	add(imE, imG, imG);
	addWeighted(imSum, 1, imG, 0.33333, 0, imSum);
	// ződ színcsatorna gradienseit adjuk hozzá az imSum-hoz
	Sobel(imGreen, imL, imL.depth(), 1, 0);
	convertScaleAbs(imL, imE);
	Sobel(imGreen, imL, imL.depth(), 0, 1);
	convertScaleAbs(imL, imG);
	add(imE, imG, imG);
	addWeighted(imSum, 1, imG, 0.33333, 0, imSum);
	// vörös színcsatorna gradienseit adjuk hozzá az imSum-hoz
	Sobel(imRed, imL, imL.depth(), 1, 0);
	convertScaleAbs(imL, imE);
	Sobel(imRed, imL, imL.depth(), 0, 1);
	convertScaleAbs(imL, imG);
	add(imE, imG, imG);
	addWeighted(imSum, 1, imG, 0.33333, 0, imG);
	// Az összesített gradiens az imG képbe került
	//Előfeldolgozási lépés, amelyek közül csak egyiket használjuk
	// 1 - gradiensek csonkolása
	//cvCmpS(imG, 32, imE, CV_CMP_LT);
	//cvSub(imG, imG, imG, imE);
	// 2 - a gradiensek kisimítása egy Gauss-féle aluláteresztő szűrővel
	GaussianBlur(imG, imG, Size(9, 9), 0);
	imshow("Gradiens", imG);
	waitKey();
	// Step 0 - inicializálás
	// Erodált gradiensek kiszámítása - a szomszédságban levő legkisebb gradiensek
	//kiszámítása
		erode(imG, imE, getStructuringElement(MORPH_RECT, Size(3, 3)));
	// A szegmentált képeket inicializáljuk egy szürke árnyalattal, ezeket elvileg mind
	//felül fogja írni az algoritmus
		imSegm.setTo(Scalar(50, 50, 50));
	imSegmMed.setTo(Scalar(150, 150, 150));
	// Egyik pixelnél sincs befelé folyás kezdetben
	imBe.setTo(Scalar(0));
	// Valódi kifelé folyási irányok: 0..7, 8 azt jelenti, hogy az adott pixelnél még nincs
	//eldöntve a kifelé folyás iránya
		imKi.setTo(Scalar(8));
	// Kezdetben sehol nincs még eldöntve a kifelé folyás iránya
	imMap.setTo(Scalar(0));
	// Step 1 - keressük meg és kezeljük le az összes képpontot, ahol a gradiens térkép
	//lejtős
		// Bejárjuk a képet (x,y)-nal
		for (int x = 0; x < imBe.cols; ++x) {
			for (int y = 0; y < imBe.rows; ++y) {
				int fp = getGray(imG, x, y);
				int q = getGray(imE, x, y);
				// ahol az erodált gradiens kisebb a lokális gradiensnél, ott lejtős helyen
				//vagyunk
					if (q < fp) {
						// megkeressük, hogy melyik irányba a legmeredekebb a lejtő
						for (uchar irany = 0; irany < 8; ++irany) {
							// létezik-e a vizsgált koordinátájú szomszéd
							if (x + dx[irany] >= 0 && x + dx[irany] < imBe.cols && y + dy[irany]
								>= 0 &&
								y + dy[irany] < imBe.rows) {
								int fpv = getGray(imG, x + dx[irany], y + dy[irany]);
								// ha az adott irany szerinti szomszéd gradiense annyi mint a
								//minimum gradiens a szomszédságban...
									if (fpv == q) {
										//...akkor beállítjuk a kifelé folyást az adott szomszéd
										//irányába
											setGray(imKi, x, y, irany);
										// bejelöljük, hogy az (x,y) képpontban megvan a kifelé
										//folyás iránya
											setGray(imMap, x, y, 255);
										// kiolvassuk a befelé folyás bitjeit a szomszédban...
										uchar volt = getGray(imBe, x + dx[irany], y + dy[irany]);
										// megmódosítjuk ...
										uchar adunk = bits[irany];
										uchar lesz = volt | adunk;
										// és visszaírjuk
										setGray(imBe, x + dx[irany], y + dy[irany], lesz);
										break;
									}
							}
						}
					}
			}
		}
	// megmutatjuk egy ablakban a lekezelt képpontok térképét és várunk gombnyomásra
	imshow("Ablak", imMap);
	waitKey();
	// Step 2 - fennsíkon levő pontok lekezelése a gradiens térképen
	// Kell egy FIFO lista amire képpontokat fogunk elhelyeni
	Point* fifo = new Point[imBe.cols * imBe.rows];
	int nextIn = 0;
	int nextOut = 0;
	// Bejárjuk a képet (x,y)-nal
	for (int x = 0; x < imBe.cols; ++x) {
		for (int y = 0; y < imBe.rows; ++y) {
			// olyan képpontot keresünk, ahol már el van döntve a kifelé folyás iránya de
			//van olyan szomszédja,
				// ahol még nincs eldöntve
				int fp = getGray(imG, x, y);
			int pout = getGray(imKi, x, y);
			if (pout == 8) continue;
			// találtunk egy olyan képpontot, ahol a kifelé folyás iránya már el van
			//döntve ...
				int added = 0;
			// ... és vizsgáljuk annak a szomszédjait
			for (uchar irany = 0; irany < 8; ++irany) {
				if (x + dx[irany] >= 0 && x + dx[irany] < imBe.cols && y + dy[irany] >= 0
					&&
					y + dy[irany] < imBe.rows) {
					int fpv = getGray(imG, x + dx[irany], y + dy[irany]);
					int pvout = getGray(imKi, x + dx[irany], y + dy[irany]);
					if (fpv == fp && pvout == 8) {
						// ha ide jutunk, akkor találtunk olyan szomszédot, ahol még
						//nincs eldöntve a kifelé folyás iránya
							// az ilyen (x,y) képpontokat felvesszük a FIFO listára
							if (added == 0) fifo[nextIn++] = Point(x, y);
						added++;
					}
				}
			}
		}
	}
	// amíg ki nem ürül a FIFO lista
	while (nextOut < nextIn) {
		// kiveszünk egy képpontot a listáról
		Point p = fifo[nextOut++];
		int fp = getGray(imG, p.x, p.y);
		// megkeressük az összes olyan szomszédját, ahol még nincs eldöntve a kifolyás
		//iránya
			for (uchar irany = 0; irany < 8; ++irany) {
				if (p.x + dx[irany] >= 0 && p.x + dx[irany] < imBe.cols && p.y + dy[irany] >=
					0 &&
					p.y + dy[irany] < imBe.rows) {
					int fpv = getGray(imG, p.x + dx[irany], p.y + dy[irany]);
					int pvout = getGray(imKi, p.x + dx[irany], p.y + dy[irany]);
					if (fp == fpv && pvout == 8) {
						// bejelöljük a kifelé folyás irányát a szomszédtól felénk
						setGray(imKi, p.x + dx[irany], p.y + dy[irany], (irany + 4) % 8);
						// bejelöljük, hogy a szomszéd képpontban megvan a kifelé folyás
						//iránya
							setGray(imMap, p.x + dx[irany], p.y + dy[irany], 255);
						// bejelöljük a befelé folyás irányát
						setGray(imBe, p.x, p.y, bits[(irany + 4) % 8] | getGray(imBe, p.x,
							p.y));
						// az újonnan bejelölt szomszéd felkerül a listára
						fifo[nextIn++] = cvPoint(p.x + dx[irany], p.y + dy[irany]);
					}
				}
			}
	}
	// megmutatjuk az ablakban a lekezelt képpontok térképét és várunk gombnyomásra
	imshow("Ablak", imMap);
	waitKey();
	// Step 3 - megkeressük a völgyekhez tartozó képpontokat a gradiens térképen
	// Keresünk olyan képpontot, amilyikből még nincs bejelölve a kifelé folyás iránya
	// Az ilyen képpontot kinevezzük lokális minimumnak és megkeressük körülötte azon
	// pontokat, amelyiknek még nincs kifelé folyása, ezekből mind a lokális minimum felé
	//fog folyni a víz
		// Szükségünk van egy veremre
		Point* stack = new Point[imBe.cols * imBe.rows];
	int nrStack = 0;
	// Bejárjuk a képet (x,y)-nal
	for (int x = 0; x < imBe.cols; ++x) {
		for (int y = 0; y < imBe.rows; ++y)
		{
			int fp = getGray(imG, x, y);
			int pout = getGray(imKi, x, y);
			// Amelyik képpontban már megvan a kifelé folyás irányam azzal nem kell
			//foglalkozni
				if (pout != 8) continue;
			// pout egy lokális minimumnak lesz kinevezve
			// Megkeressük azokat a szomszédokat, amelyeknek még nincs meg a kifelé
			//folyási irányuk
				for (uchar irany = 0; irany < 8; ++irany) {
					if (x + dx[irany] >= 0 && x + dx[irany] < imBe.cols && y + dy[irany] >= 0 &&
						y + dy[irany] < imBe.rows)
					{
						int fpv = getGray(imG, x + dx[irany], y + dy[irany]);
						int pvout = getGray(imKi, x + dx[irany], y + dy[irany]);
						if (pvout == 8 && fp == fpv)
						{
							// itt találtunk olyan szomszédot
						   // bejelöljük a kifelé folyást a lokális minimum felé
							setGray(imKi, x + dx[irany], y + dy[irany], (irany + 4) % 8);
							setGray(imMap, x + dx[irany], y + dy[irany], 255);
							setGray(imBe, x, y, bits[(irany + 4) % 8] | getGray(imBe, x, y));
							// a szomszéd képpontot betesszük a verembe
							stack[nrStack++] = cvPoint(x + dx[irany], y + dy[irany]);
						}
					}
				}
			// amíg ki nem ürül a verem
			while (nrStack > 0)
			{
				// kiveszünk egy képpontot és megnézzük, hogy a szomszédai között van-e
				//olyan, akinek nincs megjelölve a
					// kifelé folyás iránya
					Point pv = stack[--nrStack];
				int fpv = getGray(imG, pv.x, pv.y);
				int pvout = getGray(imKi, pv.x, pv.y);
				for (uchar irany = 0; irany < 8; ++irany) {
					if (pv.x + dx[irany] >= 0 && pv.x + dx[irany] < imBe.cols && pv.y +
						dy[irany] >= 0 &&
						pv.y + dy[irany] < imBe.rows) {
						// itt találtunk létező szomszédot
						int fpvv = getGray(imG, pv.x + dx[irany], pv.y + dy[irany]);
						int pvvout = getGray(imKi, pv.x + dx[irany], pv.y + dy[irany]);
						//if (fpv==fpvv && pvvout==8 && (!(pv.x+dx[pvout]==x &&
						//pv.y + dy[pvout] == y)))
						if (fpv == fpvv && pvvout == 8 && (!(pv.x + dx[irany] == x &&
							pv.y + dy[irany] == y))) {
							// itt találtunk olyan szomszédot
						   // bejelöljük a kifelé folyást pout felé
							setGray(imMap, pv.x + dx[irany], pv.y + dy[irany], 255);
							setGray(imKi, pv.x + dx[irany], pv.y + dy[irany], (irany + 4)
								% 8);
							setGray(imBe, pv.x, pv.y, bits[(irany + 4) % 8] |
								getGray(imBe, pv.x, pv.y));
							// a szomszéd képpontot betesszük a verembe
							stack[nrStack++] = Point(pv.x + dx[irany], pv.y + dy[irany]);
						}
					}
				}
			}
		}
	}
	// megmutatjuk az ablakban a lekezelt képpontok térképét és várunk gombnyomásra
	// itt már csak izolált fekete képpontok lesznek a fehér képen, ezek a lokális
	//minimumok
	imshow("Ablak", imMap);
	waitKey();
	// Step 4
	// feltérképezzük a vízgyűjtő medencéket a lokális minimumokból kiindulva a víz
	//folyásával fordított irányba haladva
		// minden vízgyűjtő medencében kiszámoljuk az átlagos és a medián színt
		// mindkettőből generálunk egy-egy külön kimeneti szegmentált képet
		// ez a puffer a medián számításához kell
		uint* medbuff = new uint[imBe.cols * imBe.rows];
	int label = 0;
	nextIn = 0;
	int spotSum[3];
	// Bejárjuk a képet (x,y)-nal
	for (int x = 0; x < imBe.cols; ++x) for (int y = 0; y < imBe.rows; ++y) {
		// keresünk lokális mimimumot
		int pout = getGray(imKi, x, y);
		if (pout != 8) continue;
		// találtunk lokális mimimumot, betesszük a verembe
		stack[nrStack++] = Point(x, y);
		for (int i = 0; i < 3; ++i) { spotSum[i] = 0; }
		// amíg üres nem lesz a verem
		while (nrStack > 0) {
			// Kiveszünk egy képpontot a veremből és megnézzük, honnan folyik felénk a
			//víz
				// Ahonnan felénk folyik a víz, azt a képpontot felvesszük az aktuális
				//régióba és
				// betesszük a verembe is.
				Point pv = stack[--nrStack];
			fifo[nextIn++] = pv;
			uchar r, g, b;
			getColor(imColor, pv.x, pv.y, r, g, b);
			spotSum[0] += (int)b;
			spotSum[1] += (int)g;
			spotSum[2] += (int)r;
			uint o = (int)r * 0x10000 + (int)g * 0x100 + (int)b;
			o += (uint)(round((float)r * 0.299 +
				(float)g * 0.587 + (float)b * 0.114) *
				0x1000000);
			medbuff[nextIn - 1] = o;
			// setGray(imLabel, pv.x, pv.y, label);
			int pvin = getGray(imBe, pv.x, pv.y);
			for (uchar irany = 0; irany < 8; ++irany) {
				if ((bits[irany] & pvin) > 0) {
					// setGray(imLabel, pv.x + dx[(irany + 4) % 8], pv.y + dy[(irany + 4) % 8],
					//label);
					stack[nrStack++] = Point(pv.x + dx[(irany + 4) % 8], pv.y +
						dy[(irany + 4) % 8]);
				}
			}
		}
		// a label azt számolja, hogy hány régió van összesen a szegmentált képen
		label++;
		if (nextIn < 2) printf("%d", nextIn);
		for (int i = 0; i < 3; ++i) {
			spotSum[i] = round(spotSum[i] / nextIn);
		}
		// kiszámoljuk a medián színt a quicksort segítségével
		qsort(medbuff, nextIn, sizeof(uint), compare);
		int medR = (medbuff[nextIn / 2] % 0x1000000) / 0x10000;
		int medG = (medbuff[nextIn / 2] % 0x10000) / 0x100;
		int medB = (medbuff[nextIn / 2] % 0x100);
		for (int i = 0; i < nextIn; ++i) //if (getGray(imMask, fifo[i].x, fifo[i].y) >
			//128)
 {
 // itt festjük ki a régiót az átlagos színnel
 setColor(imSegm, fifo[i].x, fifo[i].y, (uchar)spotSum[2], (uchar)
	 spotSum[1], (uchar)spotSum[0]);
 // itt festjük ki a régiót a medián színnel
 setColor(imSegmMed, fifo[i].x, fifo[i].y, (uchar)medR, (uchar)medG,
	 (uchar)medB);
 }
		nextIn = 0;
	}
	// memória felszabadítás
	free(fifo);
	free(stack);
	free(medbuff);
	// no more steps
	printf("\nRegions: %d \n", label);
	// megmutatjuk egy ablakban a medián színekkel készített képet
	imshow("Median", imSegmMed);
	// megmutatjuk egy masik ablakban az átlagos színekkel készített képet
	imshow("Atlag", imSegm);
	waitKey();
}
//A következő segédfüggvényeket kell megírni :
// Ezzel a függvénnyel kiolvashatjuk az im színes kép (x,y) koordinátájú képpontjának
//színét
// A csatornák sorrendje blue green red
void getColor(Mat im, int x, int y, uchar& blue, uchar& green, uchar& red);
void setColor(Mat im, int x, int y, uchar blue, uchar green, uchar red);
uchar getGray(const Mat& im, int x, int y);
void setGray(Mat& im, int x, int y, uchar v);
// Segédfüggvény a quicksort algoritmushoz
// p1 > p2 → 1; p1 < p2 → -1;
int compare(const void* p1, const void* p2);



int regionGrowing(Mat im, Point p0, Point& pbf, Point& pja) {
	int count = 0;
	Point* fifo = new Point[0x100000];
	int nextIn = 0;
	int nextOut = 0;
	pbf = p0;
	pja = p0;
	if (getGray(im, p0.x, p0.y) < 128)
		return 0;
	fifo[nextIn++] = p0;
	setGray(im, p0.x, p0.y, 100);
	while (nextIn > nextOut) {
		Point p = fifo[nextOut++];
		++count;
		if (p.x > 0)
			if (getGray(im, p.x - 1, p.y) > 128)
			{
				fifo[nextIn++] = Point(p.x - 1, p.y);
				setGray(im, p.x - 1, p.y, 100);
				if (pbf.x > p.x - 1) pbf.x = p.x - 1;
			}
		if (p.x < im.cols - 1)
			if (getGray(im, p.x + 1, p.y) > 128)
			{
				fifo[nextIn++] = Point(p.x + 1, p.y);
				setGray(im, p.x + 1, p.y, 100);
				if (pja.x < p.x + 1) pja.x = p.x + 1;
			}
		if (p.y > 0)
			if (getGray(im, p.x, p.y - 1) > 128)
			{
				fifo[nextIn++] = Point(p.x, p.y - 1);
				setGray(im, p.x, p.y - 1, 100);
				if (pbf.y > p.y - 1) pbf.y = p.y - 1;
			}
		if (p.y < im.rows - 1)
			if (getGray(im, p.x, p.y + 1) > 128)
			{
				fifo[nextIn++] = Point(p.x, p.y + 1);
				setGray(im, p.x, p.y + 1, 100);
				if (pja.y < p.y + 1) pja.y = p.y + 1;
			}
	}
	delete[]fifo;
	return count;
}


void lab12()
{
	//VideoCapture cap("felho.avi");
	VideoCapture cap("IMG_6909.MOV");
	if (!cap.isOpened())
	{
		cout << "Error opening video stream or file" << endl;
		return;
	}
	Mat frame;
	Mat framegray = frame.clone();
	Mat edge,draw;
	Mat frameKi = frame.clone();
	//Capture frame-by-frame
	Mat frame8;
	Mat eredmeny;
	int i=0;
	while(1)
	{
		cap >> frame;
		//If the frame is empty, break immediately
		if (frame.empty())
		{
			break;
		}
		//feher feketeben
		cvtColor(frame, framegray, COLOR_BGR2GRAY);
		//imshow("video", frame);
		//imshow("videogray", framegray);
		waitKey(10);
		//canny
		/*Canny(framegray, edge, 50, 150, 3);
		edge.convertTo(draw, CV_8U);
		imshow("videocanny", draw);
		waitKey(10);*/
		//medianBlur
		/*	medianBlur(frame, frameKi, 15);
			imshow("Kep", frameKi);
			waitKey(100);*/
		//GaussianBlur
			////blur(frame, frameKi, Size(k, k));
			//GaussianBlur(frame, frameKi, Size(3, 3),1);
			//imshow("Kep", frameKi);
			//waitKey(100);
		//alulatereszto szuro
		/*float szamok[9] = { 0.1, 0.1, 0.1, 0.1, 0.2, 0.1, 0.1, 0.1, 0.1 };
		Mat maszk = Mat(3, 3, CV_32FC1, szamok);
			filter2D(frame, frame, -1, maszk);
			imshow("Kep", frame);
			waitKey(50);*/
		//felulatereszto
		/*	int k = 1;
			float szamok[9] = { 0, -k / 4, 0, -k / 4, 1 + k, -k / 4, 0, -k / 4, 0 };
			Mat maszk = Mat(3, 3, CV_32FC1, szamok);
			filter2D(frame, frameKi, -1, maszk);
			imshow("Kep", frameKi);
			waitKey(1000);*/

		
		//Hisztogram kiegyenlites-???????????????????????????????????????????????????????????????????
		//atalakitani ycrc-be
		/*Mat dst=frame.clone();
		equalizeHist(frame, dst);
		imshow("Source image", frame);
		imshow("Equalized Image", dst);
		waitKey();*/
		//kicsinyitve
		/*resize(frame, frame, Size(frame.cols / 4, frame.rows / 4));
		imshow("video", frame);
		waitKey(10);*/
		//nagyitva
		/*resize(frame, frame, Size(frame.cols * 4, frame.rows * 4));
		imshow("video", frame);
		waitKey(10);*/





		
		//8as feladat
		resize(frame, frame, Size(frame.cols / 4, frame.rows / 4));
		imshow("video", frame);
		waitKey(10);
		i++;
		if (i == 7)
		{
			frame8 = frame;
			//imshow("hatter", frame8);
		}
		if (i > 13)
		{
			eredmeny = ((frame8 - frame) + (frame - frame8));
			//imshow("eredmeny_abszolut_kulonbseg", eredmeny);
			Mat rgb[3], & r = rgb[0], & g = rgb[1], & b = rgb[2];
			split(eredmeny, rgb);
			r = r + g;
			r = r + b;
			threshold(r, r, 170, 255, THRESH_BINARY);
			erode(r, r, getStructuringElement(MORPH_RECT, Size(3, 3)));
			//imshow("3szincsatornaosszeg", r);

			Point pbf, pja;
			int nrRect=0;
			int roiSize;
			Rect roi;
			for (int x = 0; x<r.cols; ++x) 
			{
				for (int y = 0; y<r.rows; ++y) 
				{
					if (getGray(r, x, y) > 128)
					{
						int res = regionGrowing(r, Point(x, y), pbf, pja);
						if (res > 500) 
						{
							if (!nrRect || res > roiSize) 
							{
								roi.x = pbf.x;
								roi.y = pbf.y;
								roi.width = pja.x - pbf.x + 1;
								roi.height = pja.y - pbf.y + 1;
								roiSize = res;
							}
							++nrRect;
						}
					}
				}
			}
			if (nrRect > 0) {
				rectangle(frame, Point(roi.x, roi.y),
					Point(roi.x + roi.width, roi.y + roi.height),
					Scalar(0, 255, 255, 0), 2);
			}
				imshow("VEGEREDMENY", frame);



		}








	}

	//When everything done, release the video capture object
	cap.release();
}
int main() {
	//intro();
	//lab01();
	//lab02();
	//lab03_01();
	//lab03_02();
	//lab03_03();
	//lab03_04();
	//lab03_05();
	//lab03_06();
	//lab04();
	//lab04_Canny();
	//lab05();
	//lab06_A();
	//lab06_B();
	//lab06_C();
	//lab06_D();
	//lab06_E();
	//lab07_1();
	//lab07_2();
	//lab08_1();
	//lab08_2();
	//lab09();
	//lab10_A();
	//lab11();
	lab12();
}